const anchor = require("@project-serum/anchor");
const assert = require("assert");
const { LAMPORTS_PER_SOL, PublicKey, Keypair, SystemProgram} = require("@solana/web3.js");
const {
  AccountLayout,
  TOKEN_PROGRAM_ID,
  SYSVAR_RENT_PUBKEY,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  createMint,
  getOrCreateAssociatedTokenAccount,
  getMint,
  getAccount,
} = require("@solana/spl-token");

describe("t10n_smartcontract", async () => {
  // Configure the client to use the local cluster.

  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.T10NSmartcontract;
  //console.log(program)

  const connection = program.provider.connection;

  //let local_wallet = program.provider.wallet.payer;

  let advisorSK = [82,90,7,245,20,144,76,2,145,5,216,62,82,58,197,97,70,28,154,216,43,43,155,62,160,179,98,144,216,57,69,175,93,148,47,73,25,69,115,25,93,186,182,175,55,212,152,66,108,103,100,10,60,138,168,110,0,62,228,105,248,50,18,211]
    .slice(0,32);  // the fromSeed() method requires 32 bytes
  let advisor = Keypair.fromSeed(Uint8Array.from(advisorSK));

  let originatorSK = [200,103,148,114,163,222,141,19,123,104,173,149,211,238,193,161,224,31,64,182,107,248,100,157,145,2,156,10,65,217,161,254,197,172,1,102,43,206,107,229,204,115,182,84,17,97,45,148,162,223,222,14,246,175,83,250,45,240,213,90,48,252,238,96]
    .slice(0,32);  // the fromSeed() method requires 32 bytes
  let originator = Keypair.fromSeed(Uint8Array.from(originatorSK));

  let receiverSK = [122,126,34,231,37,152,222,4,91,14,197,85,194,208,212,148,41,19,60,94,241,144,50,122,227,209,27,193,140,48,11,17,16,77,52,222,40,175,190,128,94,215,177,19,121,195,209,153,45,114,209,33,29,49,23,178,25,241,242,164,181,32,148,67]
    .slice(0,32);  // the fromSeed() method requires 32 bytes
  let receiver = Keypair.fromSeed(Uint8Array.from(receiverSK));

  let mint // token address, TODO later with pda
  let originator_ata;
  let receiver_ata;

  let newBuilding = Keypair.generate(); // generate the pubkey for the new building account

  it('Creating a new building by a different originator than my local wallet', async () => {

    if(await connection.getBalance(advisor.publicKey) < 1) {
      await airdropAccount(connection, advisor, 10)
    }
    if(await connection.getBalance(originator.publicKey) < 1) {
      await airdropAccount(connection, originator, 10)
    }

    await program.rpc.createBuilding(
      new anchor.BN(20000e6),
      new anchor.BN(18000e6),
      new anchor.BN(50e6),
      false, {
        accounts: {
          building: newBuilding.publicKey, // got the pubKey of the account
            // (building's account keypair) generated by the program
              // to create the account of the new building
          advisor: advisor.publicKey,
          originator: originator.publicKey,
          systemProgram: SystemProgram.programId, // solana's official system
            // (program pubkey)
        },
        signers: [newBuilding, advisor], // Anchor will only automatically sign transactions using our wallet which is why
            // we need to explicitly sign here with advisor and the new create account
      }
    );

    console.log("\nBuilding's publickey: " + newBuilding.publicKey)
    console.log("Building account succesfully created")

    // Here is after sending the transaction to the blockchain.
    // Fetch the account details of the created buildingWalletOriginator
    const buildingAccount = await program.account.building.fetch(newBuilding.publicKey)

    assert.strictEqual(buildingAccount.advisor.toBase58(), advisor.publicKey.toBase58())
    assert.strictEqual(buildingAccount.totalSupply.toNumber(), 20000e6)
    assert.strictEqual(buildingAccount.tokenToSell.toNumber(), 18000e6)
    assert.strictEqual(buildingAccount.tokenValue.toNumber(), 50e6)

  });

  it('Mint some token', async () => {

    // MINT ACCOUNT
    // This mint account is later used to mint tokens to a token account and create the initial supply
    mint = await createMintAccount(connection, originator, advisor)
    console.log(`\nToken identifier (mint account): ${mint.toString()}`);

    //TODO: implement PDAs
    /* const [newBuilding, building_bump] = await PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode("my-first-building-seed"))],
      program.programId
    ); */

    // (ASSOCIETED) TOKEN ACCOUNT to let the originator receive the tokens minted
    originator_ata = await associetedTokenAccount(connection, originator, mint)
    console.log(`\nOriginator ATA token's amount before mint: ${(await connection.getTokenAccountBalance(originator_ata.address)).value.amount}`)

    console.log(`Minting to originator_ata 10 token...`);
    // mint tokens to originator ATA
    await program.rpc.mintToken(
      mint,
      {
      accounts: {
          building: newBuilding.publicKey,
          mint: mint,
          mintAuthority: advisor.publicKey,
          receiverTokenAccount: originator_ata.address,
          tokenProgram: TOKEN_PROGRAM_ID,
      },
      signers: [advisor],
    });

    // Here is after sending the transaction to the blockchain.
    // Fetch the account details of the created new building
    const newBuildingAccount = await program.account.building.fetch(newBuilding.publicKey)

    assert.strictEqual(newBuildingAccount.advisor.toBase58(), advisor.publicKey.toBase58())
    assert.strictEqual(newBuildingAccount.totalSupply.toNumber(), 20000e6)
    assert.strictEqual(newBuildingAccount.tokenToSell.toNumber(), 18000e6)
    assert.equal(newBuildingAccount.token.toBase58(), mint.toBase58())

    //console.log("Originator ata: "+ originator_ata.address)
    console.log(`Originator ATA token's amount after mint: ${(await connection.getTokenAccountBalance(originator_ata.address)).value.amount}`)

    //console.log(`\nOriginator: `+ originator.publicKey)
    await printAssocietedTokenAccounts(connection, originator, "Originator")

    console.log("token successfully minted")
  });

  it('transfer tokens', async () => {

    //originator_ata = await associetedTokenAccount(originator, mint) //alreaty gotten
    //console.log(`\nOriginator ATA token's amount before transfer: ${(await connection.getTokenAccountBalance(originator_ata.address)).value.amount}`)
    if(await connection.getBalance(receiver.publicKey)  < 1) {
      await airdropAccount(connection, receiver, 10)
    }

    receiver_ata = await associetedTokenAccount(connection, receiver, mint)
    //console.log(`Receiver ATA token's amount before transfer: ${(await connection.getTokenAccountBalance(receiver_ata.address)).value.amount}`)

    let amount = new anchor.BN(1000e6) // 1000

    await program.rpc.transferWrapper(amount, {
        accounts: {
            sender: originator.publicKey,
            senderTokenAccount: originator_ata.address,
            receiverTokenAccount: receiver_ata.address,
            mint: mint,
            tokenProgram: TOKEN_PROGRAM_ID,
        },
        signers: [originator],
    });

    let originator_ata_token_amount = await connection.getTokenAccountBalance(originator_ata.address);
    console.log(`\nOriginator ATA token's amount after transfer: ${originator_ata_token_amount.value.amount}`)
    let receiver_ata_token_amount = await connection.getTokenAccountBalance(receiver_ata.address)
    console.log(`Receiver ATA token's amount after transfer: ${receiver_ata_token_amount.value.amount}`)

    await printAssocietedTokenAccounts(connection, originator, "Originator")

    await printAssocietedTokenAccounts(connection, receiver, "Receiver")

    console.log("token successfully transfered")

  });

  /* it('Can filter building by advisors', async () => {

    const advisorPubKey = program.provider.wallet.publicKey;
    const buildingAccounts = await program.account.building.all([
      {
        memcmp: { // usefull to filter building, in this case from a given originator
            // this filter can only compare exact data, cannot tell for example
              // if something is lower than something else
          offset: 40, // saying from which byte to start looking for the advisor
            // in the advisor's array of bytes
          bytes: advisorPubKey.toBase58(), // pubkey of the originator to look for
          //bytes: bs58.encode(Buffer.from('veganism')) to encode string to the right format
        }
      }
    ]);

    assert.strictEqual(buildingAccounts.length, 1)
    assert.ok(buildingAccounts.every(buildingAccount => {
        // every returns true if all the elements satisfy the condition
      return buildingAccount.account.advisor.toBase58() === advisorPubKey.toBase58()
    }))

  }); */
});

async function airdropAccount(connection, user, amount) {
  // request for airdrop to pay for originator's transactions
  const airdropSignature = await connection.requestAirdrop(
      user.publicKey,
      amount*LAMPORTS_PER_SOL,
  );
  // airdrop carried out
  await connection.confirmTransaction(airdropSignature);
}

async function createMintAccount(connection, payer, authority) {
  // This mint account is the token identifier, later used to mint tokens to a token account
      //and create the initial supply
  return await createMint(
      connection, // connection
      payer, // fee payer Keypair
      authority.publicKey, // mint authority publickey
      authority.publicKey, // freeze authority publickey (you can use `null` to disable it. when you disable it, you can't turn it on again)
      6 // decimals
  );

}

async function associetedTokenAccount(connection, user, mint) {
  return await getOrCreateAssociatedTokenAccount(
      connection, // connection
      user, // fee payer
      mint, // mint
      user.publicKey // owner,
  );
}

async function printAssocietedTokenAccounts(connection, user, role) {
  const associatedTokenAccounts = await connection.getTokenAccountsByOwner(
      user.publicKey,
      { programId: TOKEN_PROGRAM_ID }
  );

  console.log(`\n${role}'s owned tokens`)
  console.log("Token                                         Balance");
  console.log("------------------------------------------------------------");

  // to get all the token accounts of an owner
  associatedTokenAccounts.value.forEach((e) => {
      const accountInfo = AccountLayout.decode(e.account.data);
      console.log(`${new PublicKey(accountInfo.mint)}   ${accountInfo.amount}`);
  })
}
